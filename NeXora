local OrionLib = loadstring(game:HttpGet(('https://raw.githubusercontent.com/jensonhirst/Orion/main/source')))()
local Window = OrionLib:MakeWindow({Name = "NeXora #1 v0.0.7 by nxthxn.dev", HidePremium = true, SaveConfig = true, ConfigFolder = "OrionNEXORA"})
local Tab = Window:MakeTab({
	Name = "Main",
	Icon = "rbxassetid://4483345998",
	PremiumOnly = false
})

local Section = Tab:AddSection({
	Name = "Auto :)"
})

OrionLib:MakeNotification({
	Name = "NeXora",
	Content = "All Started good !",
	Image = "rbxassetid://4483345998",
	Time = 3
})

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local VirtualInputManager = game:GetService("VirtualInputManager")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

local BASE_DETECTION_RANGE = 10 -- Distance minimale de base pour la d√©tection
local DEFAULT_COLOR = Color3.fromRGB(128, 128, 128) -- Couleur de base de la balle
local IGNORE_COLOR = Color3.fromRGB(0, 17, 165) -- Couleur √† ignorer (exemple : bleu)
local detectionRange = BASE_DETECTION_RANGE
local lastBallPosition = nil
local lastBallVelocity = Vector3.new(0, 0, 0) -- Pour stocker la derni√®re v√©locit√© de la balle
local lastClickTime = 0 -- Pour √©viter les clics trop rapides
local isClicking = false -- Pour savoir si on a d√©j√† cliqu√©
local hasClicked = false -- Nouvelle variable pour v√©rifier si le clic a √©t√© effectu√©
local autoParryEnabled = false -- √âtat du toggle

local PREDICTION_STEPS = 5 -- Nombre d'√©tapes pour la pr√©diction de la trajectoire
local lastBallPositions = {} -- Table pour stocker les positions pass√©es de chaque balle

-- Mise √† jour de la zone apr√®s la mort du joueur
local function updateZone()
    character = player.Character or player.CharacterAdded:Wait()
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
end

player.CharacterAdded:Connect(updateZone)

-- Fonction pour simuler un clic
local function simulateClick()
    local screenCenter = Vector2.new(game:GetService("GuiService"):GetScreenResolution().X / 2, game:GetService("GuiService"):GetScreenResolution().Y / 2)

    -- Simuler un clic au centre de l'√©cran
    VirtualInputManager:SendMouseButtonEvent(screenCenter.X, screenCenter.Y, 0, true, game, 1)  
    task.wait(0.00001)  
    VirtualInputManager:SendMouseButtonEvent(screenCenter.X, screenCenter.Y, 0, false, game, 1)  
end

-- Fonction pour pr√©dire la trajectoire de la balle
local function predictBallTrajectory(ball)
    if not lastBallPositions[ball] then
        lastBallPositions[ball] = {}
    end

    table.insert(lastBallPositions[ball], ball.Position)
    if #lastBallPositions[ball] > PREDICTION_STEPS then
        table.remove(lastBallPositions[ball], 1)
    end

    if #lastBallPositions[ball] >= 2 then
        local totalDirection = Vector3.zero
        for i = 2, #lastBallPositions[ball] do
            totalDirection = totalDirection + (lastBallPositions[ball][i] - lastBallPositions[ball][i - 1]).Unit
        end
        return totalDirection / (#lastBallPositions[ball] - 1)
    end

    return ball.Velocity.Unit
end

-- Fonction pour activer/d√©sactiver l'Auto Parry
RunService.Heartbeat:Connect(function(deltaTime)
    if not autoParryEnabled then return end

    local ballsFolder = Workspace:FindFirstChild("Balls")
    if ballsFolder then
        local targetBall = nil
        local minDistance = math.huge

        for _, ball in ipairs(ballsFolder:GetChildren()) do
            if ball:IsA("Part") and ball.Color ~= IGNORE_COLOR then
                local distance = (ball.Position - humanoidRootPart.Position).Magnitude
                if distance < minDistance then
                    minDistance = distance
                    targetBall = ball
                end
            end
        end

        if targetBall then
            local ballColor = targetBall.Color

            if lastBallPosition then
                local predictedDirection = predictBallTrajectory(targetBall)
                local ballToPlayer = humanoidRootPart.Position - targetBall.Position
                local dotProduct = predictedDirection:Dot(ballToPlayer.Unit)

                local ballVelocity = (targetBall.Position - lastBallPosition) / deltaTime
                local ballSpeed = ballVelocity.Magnitude
                lastBallPosition = targetBall.Position

                local targetDetectionRange = BASE_DETECTION_RANGE + (ballSpeed * 0.117)
                detectionRange = math.min(targetDetectionRange, 150)

                if minDistance <= detectionRange and dotProduct > 0 then
                    if ballColor ~= DEFAULT_COLOR and not hasClicked then
                        simulateClick()
                        hasClicked = true
                    end
                end
            else
                lastBallPosition = targetBall.Position
            end
        else
            lastBallPosition = nil
            hasClicked = false
        end
    end

    local ballsFolder = Workspace:FindFirstChild("Balls")
    if ballsFolder then
        for _, ball in ipairs(ballsFolder:GetChildren()) do
            if ball:IsA("Part") and ball.Color == DEFAULT_COLOR then
                hasClicked = false
            end
        end
    end
end)

-- Ajout du Toggle dans l'onglet
Tab:AddToggle({
    Name = "Auto Parry",
    Default = false,
    Callback = function(Value)
        autoParryEnabled = Value
    end    
})


Tab:AddButton({
	Name = "Manual Spam [E]",
	Callback = function()
      		local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local VirtualInputManager = game:GetService("VirtualInputManager")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local spamEnabled = false -- √âtat du spam

-- üìå Fonction pour cr√©er l'interface utilisateur
local function createUI()
    -- V√©rifier si l'UI existe d√©j√† et la supprimer
    if player:FindFirstChild("PlayerGui") then
        local existingGui = player.PlayerGui:FindFirstChild("SpamToggleGUI")
        if existingGui then
            existingGui:Destroy()
        end
    end

    -- Cr√©ation de l'UI
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "SpamToggleGUI"
    screenGui.Parent = player:WaitForChild("PlayerGui")

    local toggleButton = Instance.new("TextButton")
    toggleButton.Parent = screenGui
    toggleButton.Size = UDim2.new(0, 100, 0, 50)
    toggleButton.Position = UDim2.new(0.85, 0, 0.1, 0)
    toggleButton.Text = spamEnabled and "Spam ON [E]" or "Spam OFF [E]"
    toggleButton.BackgroundColor3 = spamEnabled and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
    toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    toggleButton.Font = Enum.Font.SourceSansBold
    toggleButton.TextSize = 18
    toggleButton.Draggable = true
    toggleButton.Active = true

    -- üìå Fonction pour activer/d√©sactiver le spam
    local function toggleSpam()
        spamEnabled = not spamEnabled
        toggleButton.Text = spamEnabled and "Spam ON [E]" or "Spam OFF [E]"
        toggleButton.BackgroundColor3 = spamEnabled and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
    end

    -- üìå Activation/d√©sactivation avec le bouton
    toggleButton.MouseButton1Click:Connect(toggleSpam)

    -- üìå Activation/d√©sactivation avec la touche "E"
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and input.KeyCode == Enum.KeyCode.E then
            toggleSpam()
        end
    end)
end

-- üìå Spammer la touche "F" si activ√©
RunService.Heartbeat:Connect(function()
    if spamEnabled then
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game)
        task.wait(0.00000000001) -- Super rapide
    end
end)

-- üìå Cr√©ation de l'UI au lancement
createUI()

-- üìå R√©g√©n√©rer l'UI apr√®s la mort du joueur
player.CharacterAdded:Connect(function()
    task.wait(1) -- Attendre la r√©apparition compl√®te
    createUI()
end)

  	end    
})


local Section = Tab:AddSection({
	Name = "others functions"
})

   Tab:AddToggle({
   Name = "TP BALL [OP]",
   Default = false,
   Callback = function(Value)
       isToggled = Value -- Mettre √† jour l'√©tat du toggle
       if Value then
           -- Activer le toggle
           local RunService = game:GetService("RunService")
           local player = game.Players.LocalPlayer

           -- Fonction pour g√©n√©rer une position al√©atoire autour de la balle (sans aller en dessous)
           local function getRandomPositionAroundBall(ballPosition)
               local radius = 15 -- Distance de 5 studs autour de la balle
               local angle = math.random() * 2 * math.pi -- Angle al√©atoire
               local offset = Vector3.new(math.cos(angle) * radius, math.random(0, radius), math.sin(angle) * radius) -- D√©calage al√©atoire
               return ballPosition + offset
           end

           -- Fonction pour se t√©l√©porter de mani√®re al√©atoire
           local function teleportRandomly()
               local ballsFolder = workspace:FindFirstChild("Balls")
               if ballsFolder and #ballsFolder:GetChildren() > 0 then
                   -- S√©lectionner un objet au hasard dans le dossier
                   local randomBall = ballsFolder:GetChildren()[math.random(1, #ballsFolder:GetChildren())]
                   local ballPosition = randomBall.Position

                   -- V√©rifier si le joueur a un personnage
                   local character = player.Character
                   local rootPart = character and character:FindFirstChild("HumanoidRootPart")

                   if rootPart then
                       -- G√©n√©rer une nouvelle position al√©atoire autour de la balle
                       local targetPosition = getRandomPositionAroundBall(ballPosition)

                       -- T√©l√©porter le personnage √† cette position
                       rootPart.CFrame = CFrame.new(targetPosition)
                   end
               end
           end

           -- Connecter la fonction √† l'√©v√©nement Heartbeat pour des t√©l√©portations rapides
           connection = RunService.Heartbeat:Connect(function()
               if not isToggled then
                   connection:Disconnect() -- Arr√™ter si le toggle est d√©sactiv√©
                   return
               end
               teleportRandomly()
           end)
       else
           -- D√©sactiver le toggle
           if connection then
               connection:Disconnect() -- Arr√™ter la connexion
           end
       end
   end,
})


   Tab:AddToggle({
   Name = "Auto Look Ball",
   Default = false,
   Callback = function(Value)
       isToggled = Value -- Mettre √† jour l'√©tat du toggle
       if Value then
           -- Activer le toggle
           local RunService = game:GetService("RunService")

           -- Fonction pour faire regarder la balle (horizontalement seulement)
           local function lookAtBall()
               local ballsFolder = workspace:FindFirstChild("Balls")
               if ballsFolder and #ballsFolder:GetChildren() > 0 then
                   -- S√©lectionner un objet au hasard dans le dossier
                   local randomBall = ballsFolder:GetChildren()[math.random(1, #ballsFolder:GetChildren())]
                   
                   -- Faire en sorte que le personnage regarde l'objet (horizontalement)
                   local character = game.Players.LocalPlayer.Character
                   if character and character:FindFirstChild("Humanoid") and character:FindFirstChild("Head") then
                       local head = character.Head
                       local ballPosition = randomBall.Position
                       local headPosition = head.Position

                       -- Ignorer la hauteur (axe Y) pour ne regarder que horizontalement
                       ballPosition = Vector3.new(ballPosition.X, headPosition.Y, ballPosition.Z)

                       -- Calculer la direction vers la balle (horizontalement)
                       local direction = (ballPosition - headPosition).Unit
                       head.CFrame = CFrame.lookAt(headPosition, headPosition + direction)
                   end
               end
           end

           -- Connecter la fonction √† l'√©v√©nement RenderStep pour une rotation fluide
           connection = RunService.RenderStepped:Connect(function()
               if not isToggled then
                   connection:Disconnect() -- Arr√™ter si le toggle est d√©sactiv√©
                   return
               end
               lookAtBall()
           end)
       else
           -- D√©sactiver le toggle
           if connection then
               connection:Disconnect() -- Arr√™ter la connexion
           end
       end
   end,
})


local Misc = Window:MakeTab({
	Name = "Misc",
	Icon = "rbxassetid://4483345998",
	PremiumOnly = false
})



local Tab = Window:MakeTab({
	Name = "Cr",
	Icon = "rbxassetid://4483345998",
	PremiumOnly = false
})
